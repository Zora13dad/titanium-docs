(window.webpackJsonp=window.webpackJsonp||[]).push([[1057],{1846:function(e,t,n){"use strict";n.r(t);var r=n(21),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"buffer-spec"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#buffer-spec"}},[e._v("#")]),e._v(" Buffer Spec")]),e._v(" "),n("h2",{attrs:{id:"contents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),n("h2",{attrs:{id:"overview"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),n("p",[e._v("Titanium mobile needs support for binary data operations. A new buffer type needs to be created that will be used for read / write operations on streams.")]),e._v(" "),n("div",{staticClass:"tip custom-block"},[n("p",{staticClass:"custom-block-title"},[e._v("ðŸ’¡ Hint")]),e._v(" "),n("p",[e._v("A separate spec exists that outlines encoding support for numeric and string values. The "),n("RouterLink",{attrs:{to:"/guide/Titanium_SDK/Titanium_SDK_Guide/Contributing_to_Titanium/Platform_Development/Specs/Encoding_Spec/"}},[e._v("Encoding Spec")]),e._v(" enables the addition of reading and writing of numeric and string values along with support for specific encoding.")],1)]),e._v(" "),n("h2",{attrs:{id:"definitions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),n("ul",[n("li",[e._v("Buffer - Generally represents temporary storage for data when moving from one location to another (such as reading data off a socket and then writing to a file). In our case, the buffer will be a container for binary data rather than being limited to only string data.")])]),e._v(" "),n("h2",{attrs:{id:"proposed-tasks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proposed-tasks"}},[e._v("#")]),e._v(" Proposed Tasks")]),e._v(" "),n("ul",[n("li",[e._v("Create Buffer data type for use with Stream IO")])]),e._v(" "),n("h3",{attrs:{id:"ti-buffer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ti-buffer"}},[e._v("#")]),e._v(" Ti.Buffer")]),e._v(" "),n("p",[e._v("In order to support generic handling of Stream operations, all read / write operations will utilize the new buffer type. Buffer type will allow for array style access for individual bytes (IE: myarray[spe:3] = 1)")]),e._v(" "),n("p",[e._v("Creating buffer object:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// the only creation argument supported is size\nBuffer Ti.createBuffer() // buffer is empty with size 0 if no size is specified\nBuffer Ti.createBuffer({length: x})\n")])])]),n("p",[e._v("Members:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/*\nlength is accessed via standard get / set methods.  When length is modified,\nthe buffer will be re-sized while preserving existing where possible.  If the new buffer size\nis smaller than the size of the existing data then the existing data will be truncated down to\nthe size of the new buffer.\n*/\nint length;\n")])])]),n("p",[e._v("Methods:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// appends specified buffer to the current buffer.  Buffer is grown dynamically to accommodate the\n// additional data if need be.  returns the number of bytes appended\nint append(Buffer sourceBuffer)\n\n// same as normal append except this allows appending only <sourceLength> bytes from the\n// <sourceBuffer> starting at <sourceOffset>. returns the number of bytes appended\nint append(Buffer sourceBuffer, int sourceOffset, int sourceLength)\n\n// inserts <sourceBuffer> into the current buffer at <offset>.  Buffer is grown to accommodate\n// the new data.  returns the number of bytes inserted\nint insert(Buffer sourceBuffer, int offset)\n\n// inserts <sourceLength> amount of data starting at <sourceOffset> from <sourceBuffer> into\n// current buffer at <offset>.  Buffer is grown to accommodate the new data.  returns\n// the number of bytes inserted\nint insert(Buffer sourceBuffer, int offset, int sourceOffset, int sourceLength)\n\n// copies the contents of <sourceBuffer> into the current buffer at <offset>.  will not\n// expand buffer if there is not enough room in the current buffer to accomodate all\n// the requested data from <sourceBuffer>.  returns the number of bytes copied\nint copy(Buffer sourceBuffer, int offset)\n\n// copies <sourceLength> contents from <sourceBuffer> starting at <sourceOffset> into the\n// current buffer at <offset>.  will not expand buffer if there is not enough room\n// in the current buffer to accomodate all the request data from <sourceBuffer>.  returns\n// the number of bytes copied\nint copy(Buffer sourceBuffer, int offset, int sourceOffset, int sourceLength)\n\nBuffer clone() // create new copy of the current buffer\n\n// creates a new buffer from the original buffer contents starting at <offset>\n// and ending at <offset> + <length>\nBuffer clone(int offset, int length)\n\nvoid fill(int fillByte) // fills buffer with <fillByte>\n// fills buffer starting from <offset> until <length> number of <fillByte> has\n// been written or the end of the buffer is reached\nvoid fill(int fillByte, int offset, int length)\n\nvoid clear() // clears buffer contents but does not change the size of the buffer\n\n// releases the space allocated to the buffer, sets length to 0.  This is effectively\n// nothing more than an alias for buffer.length = 0\nvoid release()\n\nString toString() // converts buffer to string\nBlob toBlob() // converts buffer to TiBlob\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);